{% extends "base.html" %}

{% block title %}
    <title>WebRTC IP Address Finder | Sergey Grishuk</title>
{% endblock %}

{% block meta_description %}
    <meta name="description" content="This page demonstrates how WebRTC can be used to discover your true IP address. WebRTC allows browsers to communicate directly, but this process can be exploited to bypass many common VPNs and proxies. By initiating a connection, a website can reveal your actual public IP address, de-anonymizing you and creating a severe privacy risk.">
{% endblock %}

{% block content %}
    <style>
        /* Basic styling to replace the <br> tag */
        #findIpBtn {
            margin-bottom: 1.5rem;
        }
    </style>
    <article>
        <h1>WebRTC IP Address Finder</h1>
        
        <blockquote>
            <p>This page demonstrates how WebRTC can be used to discover your true IP address. WebRTC allows browsers to communicate directly, but this process can be exploited to bypass many common VPNs and proxies. By initiating a connection, a website can reveal your actual public IP address, de-anonymizing you and creating a severe privacy risk.</p>
            <footer>
                <!-- <a href="/posts/1.html">‚Üê Back to the full article on Cookieless Tracking Business Risks</a> -->
            </footer>
        </blockquote>

        <hr>

        <button id="findIpBtn">Find My IP Addresses</button>

        <h2>Discovered IP Addresses:</h2>
        <pre id="ipList">Click the button to start the search...</pre>

        <script>
            const findIpBtn = document.getElementById('findIpBtn');
            const ipList = document.getElementById('ipList');

            findIpBtn.addEventListener('click', () => {
                findIpBtn.disabled = true;
                ipList.textContent = 'Searching for IP addresses...';
                
                if (!window.RTCPeerConnection) {
                    ipList.textContent = 'WebRTC is not supported by your browser.';
                    findIpBtn.disabled = false;
                    return;
                }

                const ipAddresses = new Set();
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                // 1. COLLECT IPs EFFICIENTLY
                // Listen for ICE candidates but DO NOT update the UI here.
                pc.onicecandidate = (event) => {
                    if (!event || !event.candidate || !event.candidate.candidate) {
                        return;
                    }
                    
                    // 2. USE ROBUST PARSING
                    // The IP is the 5th field in the candidate string. Split and grab it.
                    const candidateFields = event.candidate.candidate.split(' ');
                    const ip = candidateFields[4];

                    // Ensure we have a valid IP and it's not a multicast address
                    if (ip && ip.indexOf('.') > -1 || ip.indexOf(':') > -1) {
                         // Some STUN servers return mDNS addresses. Filter them out.
                        if (!ip.endsWith('.local')) {
                            ipAddresses.add(ip);
                        }
                    }
                };
                
                // 3. CENTRALIZE FINALIZATION LOGIC
                // Use 'icegatheringstatechange' as the single source of truth for completion.
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === 'complete') {
                        findIpBtn.disabled = false;
                        
                        // 4. UPDATE UI ONCE
                        // Now that we have all IPs, update the list.
                        if (ipAddresses.size > 0) {
                            updateIpList(ipAddresses);
                        } else {
                            ipList.textContent = 'No IP addresses found. Your browser might be blocking WebRTC requests.';
                        }
                    }
                };

                // Trigger the ICE gathering process
                pc.createDataChannel('');
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .catch(err => {
                        console.error("Error creating offer:", err);
                        ipList.textContent = `Error: ${err.toString()}`;
                        findIpBtn.disabled = false;
                    });
            });

            function updateIpList(ipSet) {
                let output = '';
                ipSet.forEach(ip => {
                    const type = isPrivateIP(ip) ? 'Local (Private) IP:' : 'Public IP:';
                    output += `${type.padEnd(20)} ${ip}\n`;
                });
                ipList.textContent = output.trim();
            }

            // Checks for both IPv4 and IPv6 private/local ranges
            function isPrivateIP(ip) {
                if (ip.includes(':')) { // IPv6
                    // Check for Loopback, Unique Local, and Link-Local addresses
                    return /^(::1|fc00:|fe80:)/i.test(ip);
                }
                // IPv4
                const parts = ip.split('.').map(Number);
                return parts[0] === 10 ||
                       (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
                       (parts[0] === 192 && parts[1] === 168) ||
                       (parts[0] === 127); // Added loopback check for completeness
            }
        </script>
    </article>
{% endblock %}
